'use strict' // Import

function _toConsumableArray(arr) {
	return (
		_arrayWithoutHoles(arr) ||
		_iterableToArray(arr) ||
		_unsupportedIterableToArray(arr) ||
		_nonIterableSpread()
	)
}

function _nonIterableSpread() {
	throw new TypeError(
		'Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.'
	)
}

function _unsupportedIterableToArray(o, minLen) {
	if (!o) return
	if (typeof o === 'string') return _arrayLikeToArray(o, minLen)
	var n = Object.prototype.toString.call(o).slice(8, -1)
	if (n === 'Object' && o.constructor) n = o.constructor.name
	if (n === 'Map' || n === 'Set') return Array.from(n)
	if (n === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
		return _arrayLikeToArray(o, minLen)
}

function _iterableToArray(iter) {
	if (typeof Symbol !== 'undefined' && Symbol.iterator in Object(iter))
		return Array.from(iter)
}

function _arrayWithoutHoles(arr) {
	if (Array.isArray(arr)) return _arrayLikeToArray(arr)
}

function _arrayLikeToArray(arr, len) {
	if (len == null || len > arr.length) len = arr.length
	for (var i = 0, arr2 = new Array(len); i < len; i++) {
		arr2[i] = arr[i]
	}
	return arr2
}

var typeChecker = require('typechecker') // Handle success case

function onSuccess(value) {
	// Reject if an error was returned
	if (typeChecker.isError(value)) return Promise.reject(value) // Success case, so return the value

	return value
}
/**
 * Ambidextrously execute the method with the passed arguments.
 * If method.length > args.length, then ambi provides the method with a completion callback as the last expected argument.
 * @param {function} method A method, that can either resolve synchronously, via a promise, or via a callback.
 * @param {*} args
 * @returns {Promise<*>} The determined result.
 */

function ambi(method) {
	for (
		var _len = arguments.length,
			args = new Array(_len > 1 ? _len - 1 : 0),
			_key = 1;
		_key < _len;
		_key++
	) {
		args[_key - 1] = arguments[_key]
	}

	/*
  Different ways functions can be called:
  ambi(function(a,next){next(null, a)}, a)
  	> method.length > args.length
  	> next will be provided automatically
  ambi(function(a){return a}, a)
  	> method.length = args.length
  	> no argument changes by ambi
  ambi(function(a){return a}, a, b)
  	> method.length < args.length
  	> no argument changes by ambi
  */
	try {
		// Inject a completion callback
		if (method.length > args.length) {
			return new Promise(function (resolve, reject) {
				var xargs = args
					.slice() // add the difference as undefined values
					.concat(new Array(method.length - args.length - 1)) // add the completion callback
					.concat([
						function ambiCallback(err) {
							if (err) return reject(err)

							for (
								var _len2 = arguments.length,
									args = new Array(_len2 > 1 ? _len2 - 1 : 0),
									_key2 = 1;
								_key2 < _len2;
								_key2++
							) {
								args[_key2 - 1] = arguments[_key2]
							}

							if (args.length === 1) return resolve(args[0])
							return resolve(args)
						},
					])
				method.apply(void 0, _toConsumableArray(xargs))
			}).then(onSuccess)
		} // Execute without a completion callback
		else {
			return Promise.resolve(method.apply(void 0, args)).then(onSuccess)
		}
	} catch (err) {
		return Promise.reject(err)
	}
} // Export

module.exports = ambi
