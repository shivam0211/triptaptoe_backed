/* eslint no-sync:0, no-unused-vars:0 */
'use strict' // Requires

function _createForOfIteratorHelper(o) {
	if (typeof Symbol === 'undefined' || o[Symbol.iterator] == null) {
		if (Array.isArray(o) || (o = _unsupportedIterableToArray(o))) {
			var i = 0
			var F = function F() {}
			return {
				s: F,
				n: function n() {
					if (i >= o.length) return { done: true }
					return { done: false, value: o[i++] }
				},
				e: function e(_e) {
					throw _e
				},
				f: F,
			}
		}
		throw new TypeError(
			'Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.'
		)
	}
	var it,
		normalCompletion = true,
		didErr = false,
		err
	return {
		s: function s() {
			it = o[Symbol.iterator]()
		},
		n: function n() {
			var step = it.next()
			normalCompletion = step.done
			return step
		},
		e: function e(_e2) {
			didErr = true
			err = _e2
		},
		f: function f() {
			try {
				if (!normalCompletion && it.return != null) it.return()
			} finally {
				if (didErr) throw err
			}
		},
	}
}

function _unsupportedIterableToArray(o, minLen) {
	if (!o) return
	if (typeof o === 'string') return _arrayLikeToArray(o, minLen)
	var n = Object.prototype.toString.call(o).slice(8, -1)
	if (n === 'Object' && o.constructor) n = o.constructor.name
	if (n === 'Map' || n === 'Set') return Array.from(n)
	if (n === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
		return _arrayLikeToArray(o, minLen)
}

function _arrayLikeToArray(arr, len) {
	if (len == null || len > arr.length) len = arr.length
	for (var i = 0, arr2 = new Array(len); i < len; i++) {
		arr2[i] = arr[i]
	}
	return arr2
}

var ambi = require('ambi')

var eachr = require('eachr')

var typeChecker = require('typechecker')

var fs = require('fs')
/**
 * @callback ObjectErrback
 * @param {Error?} error An error if one occured.
 * @param {object} [result]
 * @returns {void}
 */

/**
 * @callback StringErrback
 * @param {Error?} error An error if one occured.
 * @param {string} [result]
 * @returns {void}
 */

/**
 * Parse an envfile string synchronously
 * @param {string} src
 * @returns {object}
 */

function parseSync(src) {
	// Try parse JSON
	try {
		return JSON.parse(src.toString())
	} catch (err) {
		// Try parse envfile string
		var result = {}
		var lines = src.toString().split('\n')

		var _iterator = _createForOfIteratorHelper(lines),
			_step

		try {
			for (_iterator.s(); !(_step = _iterator.n()).done; ) {
				var line = _step.value
				var match = line.match(/^([^=:#]+?)[=:](.*)/)

				if (match) {
					var key = match[1].trim()
					var value = match[2].trim()
					result[key] = value
				}
			}
		} catch (err) {
			_iterator.e(err)
		} finally {
			_iterator.f()
		}

		return result
	}
}
/**
 * Parse an envfile string
 * @param {string} src
 * @param {ObjectErrback} next
 * @returns {void}
 */

function parse(src, next) {
	// Call the synchronous method asynchronously and avoid zalgo by wrapping in nextTick
	process.nextTick(function () {
		ambi(parseSync, src, next)
	})
}
/**
 * Parse an env file asynchronously
 * @param {string} filePath
 * @param {ObjectErrback} next
 * @returns {void}
 */

function parseFile(filePath, next) {
	// Read
	fs.readFile(filePath, function (err, data) {
		// Check
		if (err) return next(err) // exit
		// Parse

		parse(data.toString(), next)
	})
}
/**
 * Parse an env file synchronously
 * @param {string} filePath
 * @returns {object}
 */

function parseFileSync(filePath) {
	// Read
	var data = fs.readFileSync(filePath) // Check the result

	if (typeChecker.isError(data)) {
		// An error occured
		return data
	} else {
		// Parse the result
		return parseSync(data.toString())
	}
}
/**
 * Turn an object into an envfile synchronously
 * @param {object} obj
 * @returns {string}
 */

function stringifySync(obj) {
	// Prepare
	var result = '' // Stringify

	eachr(obj, function (value, key) {
		if (key) {
			var line = ''.concat(key, '=').concat(String(value))
			result += line + '\n'
		}
	}) // Return

	return result
}
/**
 * Turn an object into envfile string
 * @param {object} obj
 * @param {StringErrback} next
 * @returns {void}
 */

function stringify(obj, next) {
	// Call the synchronous method asynchronously and avoid zalgo by wrapping in nextTick
	process.nextTick(function () {
		ambi(stringifySync, obj, next)
	})
}

module.exports = {
	parseFile: parseFile,
	parseFileSync: parseFileSync,
	parse: parse,
	parseSync: parseSync,
	stringify: stringify,
	stringifySync: stringifySync,
}
